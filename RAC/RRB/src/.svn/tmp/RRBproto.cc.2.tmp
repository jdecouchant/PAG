//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see http://www.gnu.org/licenses/.
// 

#include "RRBproto.h"
#include "TCPCommand_m.h"
#include<fstream>
Define_Module(RRBproto);
ofstream fic("dist.txt",ios::out|ios::app);
//static double distance_moyenne = 0;
/////////////////////
/*fonction intermediaire renvoyant vraie si a appartient au vecteur v*/
bool isElt(int a, vector<int> v)
{
    for (size_t i = 0; i < v.size(); i++)
        if (v[i] == a) return true;
    return false;
}
////////////////////


static bool build_rings = true;
static vector<Ring*> rings;

#define MSGKIND_CONNECT 0x2000

void RRBproto::initialize()
{
    numSessions = numBroken = packetsSent = packetsRcvd = bytesSent = bytesRcvd = 0;
    WATCH(numSessions);
    WATCH(numBroken);
    WATCH(packetsSent);
    WATCH(packetsRcvd);
    WATCH(bytesSent);
    WATCH(bytesRcvd);

    //Initialisation des param√®tres du protocole
    nbNodes = par("nbNodes");
    t = par("t");
    init = true;
    sent = 0;

    //Ouverture d'une connection TCP
    TCPSocket socketIn;
    //socket = new TCPSocket();
    int portIn = par("connectPort");
    socketIn.bind(portIn);
    socketIn.setOutputGate(gate("tcpOut"));
    socketIn.listen();

//    timeoutMsg = new cMessage("timerConnect");
//    timeoutMsg->setKind(MSGKIND_CONNECT);
//    scheduleAt((simtime_t) 1, timeoutMsg);

    timer = new cMessage("timer");
    scheduleAt(1.0, timer);

    sendTime = new cMessage("sendTime");
    //int taille = getParentModule()->getSubmodule("Test")->par("msgSize");
    scheduleAt(0.00009*(2*t+1),sendTime);

}

void RRBproto::handleMessage(cMessage* msg)
{


    // √† revoir!! trop d'appels de cette fonction
    //vector<Node> vecNodes = getNodes();

    /*On construit les anneaux une seule fois*/
    if(build_rings)
    {
        rings = buildRings();
//                for(int i=0;i<2*t+1;i++)
//                {
//                    fic <<"RING "<< i <<"\n";
//                    for(int j=0;j<nbNodes;j++)
//                    {
//                        fic<<rings[i]->set_of_nodes[j].node_id<<" ";
//                        //ev<<rings[i]->set_of_nodes[j].address<<"\n";
//                    }
//                    fic<<"\n";
//                    fic <<"::::::::::::::\n";
//                }
        //                map<int,int> myMap;
        //                computeDistance(0,0,myMap,0);
        //
        //                for(map<int,int>::iterator it=myMap.begin();it!=myMap.end();++it)
        //                {
        //                    fic << it->first <<" "<<it->second <<"\n";
        //                }


        build_rings = false;
    }
    /*construction de la liste de predecesseurs et de successeurs pour chacun des
     * noeuds */
    if(init)
    {
        buildLists(rings);
        connect_to_followers();
        init = false;
    }

//    if(msg == timeoutMsg)
//    {
//        //buildLists(rings);
//        connectAll();
//    }
    /*Mise en place du timer pour attendre le message RRBmsg des autres predecesseurs*/

    if(msg==timer) //le timer a expiré
    {

        //on decremente le compteur de chacun des elements du map
        for(map<int,Data>::iterator it=save_buffer.begin(); it!=save_buffer.end(); ++it)
        {
            it->second.counter--;
            if(it->second.counter == 0)
            {
                //on blackliste les noeuds qui n'ont pas envoyé leur message
                ev <<"======= Debut du blacklistage ======\n";
                for(int i=0;i<2*t+1;i++)
                {
                    if(!containNode(predecessors[i],it->second.buffer))
                    {
                        blacklist.push_back(predecessors[i]);
                        //blacklist.push_back(*i);
                    }
                }
                /*on nettoie les cases dont counter=0 après le
                 * blacklistage*/
                save_buffer.erase(it);
            }
        }

        scheduleAt(simTime()+1.0,timer); //on r√©unitialise le timer
    }
    else
    {


        /*Le message est reçu pour la première fois par le sous module RRB,
         * on le broadcaste. Ce message vient du module Test en dessus du RRB */
        if(msg->arrivedOn("appIn"))
        {
            RRBmsg *m = check_and_cast<RRBmsg*>(msg);
            /*on met l'id du message dans le buffer_msg_id
             * pour que le noeud qui a envoyé ne reçoive le même message */
            //buffer_msg_id.push_back(m->getRRBmsg_id());
            //buffer_msg_id.insert(m->getRRBmsg_id());
            //on broadcaste aux followers du noeud courant
            //broadcast(m);
            send_queue.insert(m);
        }
        else
        {
            /*Reception d'un message RRBmsg*/
            if(strcmp(msg->getClassName(),"RRBmsg")==0)
            {
                RRBmsg *m = check_and_cast<RRBmsg*>(msg);

                /*On vérifie si le noeud source appartient à la liste des predecesseurs
                 * du noeud courant*/
                if(!containNode(m->getSrc(),predecessors))
                {
                    ev <<"STOP: Le noeud source n'est pas dans predecessors\n";
                    return;
                }

                /*on vérifie s'il(le noeud courant) re√ßoit le message pour la premi√®re fois */
                //if(!isElt(m->getRRBmsg_id(),buffer_msg_id))
                if((buffer_msg_id.insert(m->getRRBmsg_id())).second)
                {

                    Node src;
                    src.node_id = getParentModule()->getIndex();
                    src.address = IPAddressResolver().addressOf(getParentModule(),IPAddressResolver().ADDR_IPv4);
                    //on delivre le message

                     m->setRecepTime(simTime());
                     deliver(m->dup());

                    /*on enregistre l'Id du message dans le buffer buffer_msg_id*/
                    //buffer_msg_id.insert(m->getRRBmsg_id());
                    /*on enregistre le noeud source dans le buffer_pred*/
                    Data d;
                    d.counter = 3;
                    d.buffer.push_back(m->getSrc());
                    save_buffer[m->getRRBmsg_id()] = d;
                    /*on change la source contenue dans le message pour le broadcaster √† nouveau
                     * aux followers du noeud courant*/

                    if(src.node_id!=m->getOrigine().node_id)
                    {    //broadcast(m);
                        m->setSrc(src);
                        m->setHopCount(m->getHopCount()+1);
                        //forward(m);
                        forward_queue.insert(m);
                    }
//                    else
//                    {
//                        m->setRecepTime(simTime());
//                        deliver(m);
//                    }

                }
                else
                {
                    /*le noeud courant a déjà reçu le message m, il enregistre donc le noeud source*/
                    //buffer_pred.push_back(m->getSrc());
                    save_buffer[m->getRRBmsg_id()].buffer.push_back(m->getSrc());
                }


            }


        }
        /*Mecanisme de fairness:ici on choisit entre broadcaster ou forwarder*/
        if(msg==sendTime)
        {
            if(!forward_queue.empty())
            {
                RRBmsg* msg = check_and_cast<RRBmsg*>(forward_queue.front());
                if(sent>=received[msg->getOrigine().node_id] || send_queue.empty())
                {

                    //broadcast(msg);
                    forward(msg);
                    received[msg->getOrigine().node_id]++;
                    forward_queue.pop();
                    delete msg;
                }
                else if(!send_queue.empty())
                {
                    RRBmsg* msg = check_and_cast<RRBmsg*>(send_queue.front());
                    //msg->setSendTime(simTime());
                    broadcast(msg);
                    send_queue.pop();
                    delete msg;
                    sent++;
                }
            }else if(!send_queue.empty())
            {
                RRBmsg* msg = check_and_cast<RRBmsg*>(send_queue.front());
                //msg->setSendTime(simTime());
                broadcast(msg);
                send_queue.pop();
                delete msg;
                sent++;
            }
            //int taille = getParentModule()->getSubmodule("Test")->par("msgSize");
            scheduleAt(simTime() + 0.00009*(2*t+1), sendTime);
        }
    }
}

void RRBproto::handleTimer(cMessage *msg)
{

}

vector<Node> RRBproto::getNodes()
{
    vector<Node> vecNodes;
    /*On recupère les adresses IP des noeuds et on le stcoke dans vecAdds
     * le vecteur 'simulation' contient tous les modules créés durant une simulation
     * le module de rang 1 correspond à la topologie réseau, donc les sous modules commencent
     * à partir de 2*/
    for(int i=2;i<nbNodes+2;i++)
    {
        cModule *mod = simulation.getModule(i);
        Node n;
        n.node_id = mod->getIndex();
        n.address = IPAddressResolver().addressOf(mod,IPAddressResolver().ADDR_IPv4);
        vecNodes.push_back(n);
    }
    return vecNodes;
}

void RRBproto::connect(TCPSocket *sock, const char *connectAddress, const int connectPort)
//void RRBproto::connect(TCPSocket *sock, IPvXAddress connectAddress,const int connectPort)
{
    //nouveau connId si ce n'est pas la première connexion
    sock->renewSocket();
    //connection
    setStatusString("connecting");
    sock->connect(IPAddressResolver().resolve(connectAddress), connectPort);
    //sock->connect(connectAddress,connectPort);
    numSessions++;
}

void RRBproto::connect_to_followers()
{
    int size = (int)followers.size();
    socketsOut = new TCPSocket[size]();
    char name[15];
    //vector<Node> vecNodes = getNodes();
    for(int i=0;i<size;i++)
    {
        //if(vecNodes.at(i).address!=IPAddressResolver().addressOf(getParentModule(),IPAddressResolver().ADDR_IPv4) &&
        //vecNodes.at(i).node_id != getParentModule()->getIndex())
        //if(i!=getParentModule()->getIndex())
        //{


            //sprintf(name,"client[%d]",i);
            sprintf(name,"client[%d]",followers.at(i).node_id);
            socketsOut[i].setOutputGate(gate("tcpOut"));
            connect(&socketsOut[i],name,(int)par("connectPort"));
            //connect(&socketsOut[i],vecNodes.at(i).address,(int)par("connectPort"));

        //}
    }
}
void RRBproto::sendPacket(TCPSocket *sock, RRBmsg* msg)
{
    sock->send(msg);
    packetsSent+=1;
    bytesSent+=msg->getByteLength();
}

void RRBproto::deliver(RRBmsg* msg)
{

    send(msg,"appOut");

}

/*Renvoie un vecteur d'anneaux et sur chaque anneau on place tous les noeuds qui
 * participent au protocole de telle sorte qu'ils n'aient pas les mêmes positions*/
vector<Ring*> RRBproto::buildRings()
{
    vector<Node> vecNodes = getNodes();
    vector<Ring*> res;
    res.resize(2*t+1);

    for(int i=0;i<2*t+1;i++)
        res[i] = new Ring();
    for(int i=0;i<2*t+1;i++)
    {
        vector<int> tmp;
        Ring *r = res[i];
        //int k = intuniform(0,nbNodes-1);
        int k = intrand(nbNodes);
        r->set_of_nodes.push_back(vecNodes[k]);
        tmp.push_back(k);
        for(int j=1;j<nbNodes;j++)
        {
            k = intrand(nbNodes);
            while(isElt(k,tmp)) k = intrand(nbNodes);
            r->set_of_nodes.push_back(vecNodes[k]);
            tmp.push_back(k);
        }
    }

    return res;

}

/*Renvoie la position d'un noeud dans un vecteur*/
int RRBproto::getNodeSuiv(int id,vector<Node> nodes)
{
    size_t i = 0;
    while(i<nodes.size() && nodes[i].node_id!=id )
        i++;
    if(i+1 == nodes.size())
    {
        return 0;
    }
    else
    {
        return i+1;
    }
}

void RRBproto::computeDistance(int id, int distance, map<int,int> &distTab, int origine)
{

    for(int i=0;i<2*t+1;i++)
    {
        int k = getNodeSuiv(id,rings[i]->set_of_nodes);

        if(rings[i]->set_of_nodes[k].node_id!=origine && (distTab[rings[i]->set_of_nodes[k].node_id]==0||
                distTab[rings[i]->set_of_nodes[k].node_id]>distance+1) )
        {
            distTab[rings[i]->set_of_nodes[k].node_id] = distance+1;

            computeDistance(rings[i]->set_of_nodes[k].node_id,distance+1,distTab,origine);
        }
    }


}

double RRBproto::getDistAvg()
{
    map<int,int> disTab;
    int myID = getParentModule()->getIndex();
    computeDistance(myID,0,disTab,myID);
    int somme = 0;
    for(map<int,int>::iterator it=disTab.begin();it!=disTab.end();++it)
    {
        somme = somme + it->second;
    }
    return (double)somme/disTab.size();
}

/*Construit les listes de predecesseurs et de successeurs d'un noeud*/
void RRBproto::buildLists(vector<Ring*> rings)
{
    //        for(int i=0;i<2*t+1;i++)
    //        {
    //            ev <<"RING "<< i <<"\n";
    //            for(int j=0;j<nbNodes;j++)
    //            {
    //                ev<<rings[i]->set_of_nodes[j].node_id<<"\n";
    //                //ev<<rings[i]->set_of_nodes[j].address<<"\n";
    //            }
    //            ev <<"::::::::::::::\n";
    //        }
    //    ev <<"#############\n";

    //On parcourt ces anneaux pour construire les listes de predecesseurs et de successeurs
    IPvXAddress add_cur = IPAddressResolver().addressOf(getParentModule(),IPAddressResolver().ADDR_IPv4);

    for(int i=0;i<2*t+1;i++)
    {
        //traitement du premier elt d'un anneau
        if(rings[i]->set_of_nodes[0].address==add_cur)
        {
            predecessors.push_back(rings[i]->set_of_nodes[nbNodes-1]);
            followers.push_back(rings[i]->set_of_nodes[1]);
        }

        //traitement du dernier elt d'un anneau
        if(rings[i]->set_of_nodes[nbNodes-1].address==add_cur)
        {
            predecessors.push_back(rings[i]->set_of_nodes[nbNodes-2]);
            followers.push_back(rings[i]->set_of_nodes[0]);

        }

        for(int j=1;j<nbNodes-1;j++)
        {
            if(rings[i]->set_of_nodes[j].address==add_cur)
            {
                predecessors.push_back(rings[i]->set_of_nodes[j-1]);
                followers.push_back(rings[i]->set_of_nodes[j+1]);
            }
        }

    }

//        fic <<"ID = "<<getParentModule()->getIndex()<<"\n";
//        fic << "predecessors = ";
//        for(size_t i=0;i<predecessors.size();i++)
//        {
//            fic << predecessors.at(i).node_id  <<" ";
//        }
//        fic << "\n";
//
//
//        fic <<"successors = ";
//        for(size_t i=0;i<followers.size();i++)
//        {
//            fic << followers.at(i).node_id <<" ";
//        }
//        fic << "\n";
//        fic <<"+++++++++++++\n";

    //    fic <<"ID = "<<getParentModule()->getIndex()<<"\n";
    //    fic << "predecessors = ";
    //    for(set<Node,classcomp>::iterator it=predecessors.begin();it!=predecessors.end();it++)
    //    {
    //        fic << it->node_id <<" ";
    //    }
    //    fic << "\n";
    //
    //
    //    fic <<"successors = ";
    //    for(set<Node,classcomp>::iterator it=followers.begin();it!=followers.end();it++)
    //    {
    //        fic << it->node_id <<" ";
    //    }
    //    fic << "\n";
    //    fic <<"+++++++++++++\n";

    //Juste une petite verification pour savoir si exactement la taille de chacune des listes vaut 2t+1
    //    ev<<"+++++++++++++\n";
    //    ev <<"SIZE_P = "<<predecessors.size()<<"\n";
    //    ev <<"SIZE_F = "<<followers.size()<<"\n";
    //    ev <<"ID = "<<getParentModule()->getIndex()<<"\n";
    //    for(int i=0;i<predecessors.size();i++)
    //    {
    //        ev << predecessors.at(i).node_id <<"\n";
    //        ev << followers.at(i).node_id <<"\n";
    //        ev <<"*********************\n";
    //    }
    //    ev<<"+++++++++++++\n";
}

void RRBproto::broadcast(RRBmsg* msg)
{

    for(int i=0;i<2*t+1;i++)
    {
        //int k = followers.at(i).node_id;
        RRBmsg* copy = msg->dup();
        copy->setSendTime(simTime());
        //sendPacket(&socketsOut[k],copy);
        sendPacket(&socketsOut[i],copy);
    }

}

void RRBproto::forward(RRBmsg* msg)
{

    for(int i=0;i<2*t+1;i++)
    {
        //int k = followers.at(i).node_id;
        sendPacket(&socketsOut[i],msg->dup());
    }

}

bool RRBproto::containNode(Node src, vector<Node> vecNodes)
{
    size_t i=0;
    while(i < vecNodes.size() && vecNodes[i].address!=src.address)
        i++;
    return i < vecNodes.size();
}

//bool RRBproto::isPredecessor(Node src)
//{
//    for(set<Node,classcomp>::iterator it=predecessors.begin();it!=predecessors.end();it++)
//    {
//        if(it->address==src.address) return true;
//    }
//    return false;
//}

void RRBproto::finish()
{
    //recordScalar("#sent",sent);
    //recordScalar("#received",received);
    distance_moyenne = distance_moyenne + getDistAvg();
    if(getParentModule()->getIndex()==nbNodes-1)
    {
        distance_moyenne = distance_moyenne/nbNodes;
        fic << nbNodes << " "<<distance_moyenne<<"\n";
        fic.close();
    }

}


